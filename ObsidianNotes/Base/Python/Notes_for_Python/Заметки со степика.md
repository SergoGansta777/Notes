---
date created: 2022-07-02 13:07
tags:
  - '#Python'
  - '#todo'
---

[[2022-06-08]]
#Python

- [ ] Подробнее ознакомиться к форматированием строк в Python: [string — Common string operations — Python 3.10.5 documentation](https://docs.python.org/3/library/string.html#custom-string-formatting) #todo

# Заметки со степика(Stepik) - Курс Pyhton для начинающих

[Catalog — Stepik](https://stepik.org/)

```toc
```

## Целочисленное деление отрицательного числа

При _целочисленном_ делении ==отрицательного== числа (да и остальных соответственно тоже) число округляется в меньшую степень, то есть следующий код выведет **-13**, а не -12:

```Python
print(-123 // 10)
```

## Остаток от деления

> [!important]

При использовании операторов **%**  и  **//**  ==НЕ СОБЛЮДАЕТСЯ СОЧЕТАТЕЛЬНЫЙ ЗАКОН== арифметики. Поясню на примере:  (34 % 7) * 5 = 30,  а   34 % (7 * 5) = 34.

## Методы строк (самые примечательные)

==Каждый метод в этой группе== поддерживает необязательные аргументы `<start>` и `<end>` - работает по принципу функции **range()**

Метод `find(<sub>, <start>, <end>)` находит **индекс первого вхождения** подстроки `<sub>` в исходной строке `s`. Если строка `s` не содержит подстроки `<sub>`, то метод возвращает значение `-1`. Мы можем использовать данный метод наравне с оператором `in` для проверки: содержит ли заданная строка некоторую подстроку или нет.

```ad-important
Методы `strip(), lstrip(), rstrip()` могут принимать на вход опциональный аргумент`<chars>`. Необязательный аргумент `<chars>`– это строка, которая определяет набор символов для удаления.

```

Метод `replace()` может принимать ==опциональный третий== аргумент `<count>`,  который определяет количество замен.

_Подробнее:_

- [Методы строк. Часть 2 — Step 1 — Stepik](https://stepik.org/lesson/303083/step/1?unit=284990)
- [Fetching Title#0f7f](https://www.programiz.com/python-programming/methods/string)
- [15 Must-Know Python String Methods | by Soner Yıldırım | Towards Data Science](https://towardsdatascience.com/15-must-know-python-string-methods-64a4f554941b)
- [Built-in Types — Python 3.10.5 documentation](https://docs.python.org/3/library/stdtypes.html)

Метод `isalnum()` определяет, состоит ли исходная строка из ==буквенно-цифровых== символов. Метод возвращает значение `True` если исходная строка является непустой и состоит **только** из буквенно-цифровых символов и `False` в противном случае.

Метод `isalpha()` определяет, состоит ли исходная строка из ==буквенных== символов. Метод возвращает значение `True` если исходная строка является непустой и состоит **только** из буквенных символов и `False` в противном случае.

Метод `isdigit()` определяет, состоит ли исходная строка **только** из ==цифровых== символов. Метод возвращает значение `True` если исходная строка является непустой и состоит **только** из цифровых символов и `False` в противном случае.

Метод `islower()` определяет, являются ли **все** буквенные символы исходной строки ==строчными== (имеют нижний регистр). Метод возвращает значение `True` если все буквенные символы исходной строки являются строчными и `False` в противном случае. **Все неалфавитные символы игнорируются!** Аналогично _isupper()_

Метод `isspace()` определяет, состоит ли исходная строка **только** из ==пробельных==[^1] символов. Метод возвращает значение `True` если строка состоит только из пробельных символов и `False` в противном случае.

## Представление строк в пямяти компьютера и таблицы кодировок

> Любой набор информации должен храниться в в видев **двоичного** числа в пямяти компьютера

### Таблица символов ASCII

**ASCII** представляет собой набор из _128 цифровых кодов_, которые обозначают английские буквы, различные знаки препинания и другие символы. Например, код ASCII для прописной английской буквы «А» (латинской) равняется 65. Когда на компьютерной клавиатуре вы набираете букву ==«А»== в верхнем регистре, в памяти сохраняется число ==65==
![[Attachments/Pasted image 20220702112833.png]]
_Набор символов ASCII_ был разработан в **начале 1960-х годов** и в конечном счете принят ==почти всеми== производителями компьютеров. Однако схема кодирования ASCII имеет _==ограничения==_, потому что она определяет коды только для 128 символов. Для того чтобы это исправить, в начале 1990-х годов был разработан набор символов _Юникода_ (**Unicode**). Это широкая схема кодирования, совместимая с ASCII, которая может также представлять символы многих языков мира. Сегодня Юникод быстро становится стандартным набором символов, используемым в компьютерной индустрии.

### Таблица символов Unicode

**Таблица символов Юникод** (_официальный сайт_ - [Unicode – The World Standard for Text and Emoji](https://home.unicode.org/)) представляет собой набор цифровых символов, которые включают в себя знаки ==почти всех письменных языков мира==. Стандарт предложен в _1991_ году некоммерческой организацией «<u>Консорциум Юникода</u>». Применение этого стандарта позволяет закодировать _очень большое число символов из разных систем письменности_: в документах, закодированных по стандарту Юникод, могут соседствовать китайские иероглифы, математические символы, буквы греческого алфавита, латиницы и кириллицы, символы музыкальной нотной нотации.

Стандарт состоит из **двух основных частей**: **==универсального набора символов==** и **==семейства кодировок==** (Unicode transformation format, UTF). Универсальный набор символов перечисляет допустимые по стандарту Юникод символы и присваивает каждому символу код в виде неотрицательного целого числа. Семейство кодировок определяет способы преобразования кодов символов для хранения на компьютере и передачи.

В Юникод все время добавляются новые символы, а сам размер этой таблицы `не ограничен` и будет только расти, поэтому сейчас при хранении в памяти одного юникод-символа может потребоваться от **1 до 8 байт**. Отсутствие ограничений привело к тому, что стали появляться символы на все случаи жизни.

```ad-important
В Python строки хранятся в виде последовательности юникод символов
```

```ad-info
Первые 128 кодов таблицы символов Unicode совпадают с ASCII.
```

Про отличие таблицы символов **Unicode** от ==кодировки UTF-8== можно почитать [тут](https://developer.roman.grinyov.name/blog/104).

Функция `ord` позволяет определить **код** некоторого символа в таблице символов ==Unicode==. Аргументом данной функции является одиночный символ.
Функция `chr` позволяет определить по коду символа сам символ. Аргументом данной функции является численный код.

[^1]: **Пробельные символы**: включает в себя **символ** пробела, табуляции \t , перевода строки \n и некоторые другие редкие **пробельные символы**, обозначаемые как \v , \f и \r . \w («w»: от английского «word» – «слово»)
