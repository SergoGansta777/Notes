[[2022-06-08]]
#Python
- [ ] Подробнее ознакомиться к форматированием строк в Python: [string — Common string operations — Python 3.10.5 documentation](https://docs.python.org/3/library/string.html#custom-string-formatting) #todo 
# Заметки со степика(Stepik) - Курс Pyhton для начинающих
[Catalog — Stepik](https://stepik.org/)
```toc
```
## Целочисленное деление отрицательного числа
При *целочисленном* делении ==отрицательного== числа (да и остальных соответственно тоже) число округляется в меньшую степень, то есть следующий код выведет **-13**, а не -12:
```Python
print(-123 // 10)
```
## Остаток от деления
> [!important]
> 
При использовании операторов **%**  и  **//**  ==НЕ СОБЛЮДАЕТСЯ СОЧЕТАТЕЛЬНЫЙ ЗАКОН== арифметики. Поясню на примере:  (34 % 7) \* 5 = 30,  а   34 % (7 \* 5) = 34.
## Методы строк (самые примечательные)
==Каждый метод в этой группе== поддерживает необязательные аргументы `<start>` и `<end>` - работает по принципу функции **range()**

Метод `find(<sub>, <start>, <end>)` находит **индекс первого вхождения** подстроки `<sub>` в исходной строке `s`. Если строка `s` не содержит подстроки `<sub>`, то метод возвращает значение `-1`. Мы можем использовать данный метод наравне с оператором `in` для проверки: содержит ли заданная строка некоторую подстроку или нет.
```ad-important
Методы `strip(), lstrip(), rstrip()` могут принимать на вход опциональный аргумент`<chars>`. Необязательный аргумент `<chars>`– это строка, которая определяет набор символов для удаления.

```
Метод `replace()` может принимать ==опциональный третий== аргумент `<count>`,  который определяет количество замен.

*Подробнее:*
- [Методы строк. Часть 2 — Step 1 — Stepik](https://stepik.org/lesson/303083/step/1?unit=284990)
- [Fetching Title#0f7f](https://www.programiz.com/python-programming/methods/string)
- [15 Must-Know Python String Methods | by Soner Yıldırım | Towards Data Science](https://towardsdatascience.com/15-must-know-python-string-methods-64a4f554941b)
- [Built-in Types — Python 3.10.5 documentation](https://docs.python.org/3/library/stdtypes.html)

Метод `isalnum()` определяет, состоит ли исходная строка из ==буквенно-цифровых== символов. Метод возвращает значение `True` если исходная строка является непустой и состоит **только** из буквенно-цифровых символов и `False` в противном случае.

Метод `isalpha()` определяет, состоит ли исходная строка из ==буквенных== символов. Метод возвращает значение `True` если исходная строка является непустой и состоит **только** из буквенных символов и `False` в противном случае.

Метод `isdigit()` определяет, состоит ли исходная строка **только** из ==цифровых== символов. Метод возвращает значение `True` если исходная строка является непустой и состоит **только** из цифровых символов и `False` в противном случае.

Метод `islower()` определяет, являются ли **все** буквенные символы исходной строки ==строчными== (имеют нижний регистр). Метод возвращает значение `True` если все буквенные символы исходной строки являются строчными и `False` в противном случае. **Все неалфавитные символы игнорируются!** Аналогично *isupper()*

Метод `isspace()` определяет, состоит ли исходная строка **только** из ==пробельных==[^1] символов. Метод возвращает значение `True` если строка состоит только из пробельных символов и `False` в противном случае.

## Представление строк в пямяти компьютера и таблицы кодировок
> Любой набор информации должен храниться в в видев **двоичного** числа в пямяти компьютера
### Таблица символов ASCII
**ASCII** представляет собой набор из *128 цифровых кодов*, которые обозначают английские буквы, различные знаки препинания и другие символы. Например, код ASCII для прописной английской буквы «А» (латинской) равняется 65. Когда на компьютерной клавиатуре вы набираете букву ==«А»== в верхнем регистре, в памяти сохраняется число ==65==
![[Attachments/Pasted image 20220702112833.png]]
*Набор символов ASCII* был разработан в **начале 1960-х годов** и в конечном счете принят ==почти всеми== производителями компьютеров. Однако схема кодирования ASCII имеет *==ограничения==*, потому что она определяет коды только для 128 символов. Для того чтобы это исправить, в начале 1990-х годов был разработан набор символов *Юникода* (**Unicode**). Это широкая схема кодирования, совместимая с ASCII, которая может также представлять символы многих языков мира. Сегодня Юникод быстро становится стандартным набором символов, используемым в компьютерной индустрии.
### Таблица символов Unicode
**Таблица символов Юникод** (*официальный сайт* - [Unicode – The World Standard for Text and Emoji](https://home.unicode.org/)) представляет собой набор цифровых символов, которые включают в себя знаки ==почти всех письменных языков мира==. Стандарт предложен в *1991* году некоммерческой организацией «<u>Консорциум Юникода</u>». Применение этого стандарта позволяет закодировать *очень большое число символов из разных систем письменности*: в документах, закодированных по стандарту Юникод, могут соседствовать китайские иероглифы, математические символы, буквы греческого алфавита, латиницы и кириллицы, символы музыкальной нотной нотации.

Стандарт состоит из **двух основных частей**: **==универсального набора символов==** и **==семейства кодировок==** (Unicode transformation format, UTF). Универсальный набор символов перечисляет допустимые по стандарту Юникод символы и присваивает каждому символу код в виде неотрицательного целого числа. Семейство кодировок определяет способы преобразования кодов символов для хранения на компьютере и передачи.

В Юникод все время добавляются новые символы, а сам размер этой таблицы `не ограничен` и будет только расти, поэтому сейчас при хранении в памяти одного юникод-символа может потребоваться от **1 до 8 байт**. Отсутствие ограничений привело к тому, что стали появляться символы на все случаи жизни.

```ad-important
В Python строки хранятся в виде последовательности юникод символов
```
```ad-info
Первые 128 кодов таблицы символов Unicode совпадают с ASCII.
```
Про отличие таблицы символов **Unicode** от ==кодировки UTF-8== можно почитать [тут](https://developer.roman.grinyov.name/blog/104).

Функция `ord` позволяет определить **код** некоторого символа в таблице символов ==Unicode==. Аргументом данной функции является одиночный символ.
Функция `chr` позволяет определить по коду символа сам символ. Аргументом данной функции является численный код.

[^1]: **Пробельные символы**: включает в себя **символ** пробела, табуляции \t , перевода строки \n и некоторые другие редкие **пробельные символы**, обозначаемые как \v , \f и \r . \w («w»: от английского «word» – «слово»)