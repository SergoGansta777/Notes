---
date created: 2022-06-21 10:33
date updated: 2022-06-21 21:30
tags:
  - '#Algorithm'
---
# Алгоритм обхода/поиска в глубину(deapth-first search)

> Go deep, head first

```toc
```

## Description

_Идея_ заключается в том, что мы двигаемся от начальной вершины (точки, места) в определенном направлении (по определенному пути) до тех пор, ==пока не достигнем конца пути или пункта назначения== (искомой вершины). Если мы достигли конца пути, но он не является пунктом назначения, то мы **возвращаемся назад** (к точке разветвления или расхождения путей) и идем по _другому_ маршруту.

### Пример

Предположим, что у нас есть ориентированный граф, который выглядит так:

![](https://habrastorage.org/r/w1560/webt/-d/dk/wt/-ddkwtwgddcvzo4mbrpzeiaklm8.png)

Мы находимся в точке «s» и нам нужно найти вершину «t». Применяя DFS, мы исследуем один из возможных путей, двигаемся по нему до конца и, если не обнаружили t, возвращаемся и исследуем другой путь. Вот как выглядит процесс:

![](https://habrastorage.org/r/w1560/webt/gd/v-/-1/gdv--18wxok-yjflx_zjlwktysi.png)

Здесь мы двигаемся по пути (p1) к ближайшей вершине и видим, что это не конец пути. Поэтому мы переходим к следующей вершине.
![](https://habrastorage.org/r/w1560/webt/6q/ia/h-/6qiah-iw-qpybs2fdw072vuvrna.png)

Мы достигли конца p1, но не нашли t, поэтому возвращаемся в s и двигаемся по второму пути.

![](https://habrastorage.org/r/w1560/webt/ck/ui/ad/ckuiadguztc8gx3r6gigroyum_a.png)

Достигнув ближайшей к точке «s» вершины пути «p2» мы видим три возможных направления для дальнейшего движения. Поскольку вершину, венчающую первое направление, мы уже посещали, то двигаемся по второму.

![](https://habrastorage.org/r/w1560/webt/1h/yz/7o/1hyz7ojpnp__g0w9sg5kr9bzeyk.png)

Мы вновь достигли конца пути, но не нашли t, поэтому возвращаемся назад. Следуем по третьему пути и, наконец, достигаем искомой вершины «t».

![](https://habrastorage.org/r/w1560/webt/oy/4d/mm/oy4dmm-velx-yladbqyvyqrbkts.png)

Так работает **DFS.** ==Двигаемся по определенному пути до конца==. Если конец пути — это _искомая_ вершина, мы _закончили_. Если нет, возвращаемся назад и двигаемся по другому пути до тех пор, пока не исследуем все варианты.

Мы следуем этому алгоритму применительно к каждой посещенной вершине.

Необходимость многократного повторения процедуры указывает на необходимость использования **рекурсии** для реализации алгоритма.

## Реализация алгоритма

Специальный **DFS-алгоритм** позволяет проверить, возможно ли добраться из одного места в другое. DFS может использоваться в ==разных целях==. От этих целей зависит то, как будет выглядеть сам алгоритм. Тем не менее, общая концепция выглядит именно так.

#### Реализация для произвольного графа

```cpp
vector<int> graph[100000];
bool used[100000];      //вместо visited массив меток обычно называют used.

void dfs(int v) {
    used[v] = true;
    cout << "DFS at vertex " << v + 1 << endl;
    for (auto u: graph[v]) {
        if (!used[u]) {
            dfs(u);
        }
    }
}
```

#### Реализация для дерева

Очень часто DFS применяется не для произвольного графа, а для _дерева_. Это позволяет реализовать алгоритм немного по другому: за счёт ==отсутствия в дереве циклов== мы можем избавиться от **массива used**. Достаточно всего лишь передавать в функцию ещё <u>один параметр</u>: **предыдущую вершину**. Этот параметр необходим, чтобы _не попасть в бесконечный цикл из двух вершин_ (постоянно проходя по одному и тому же ребру).

```cpp
vector<int> graph[100000];    //храним дерево как и обычный граф

void dfs(int v, int p = -1) {   //p (от parent) - предыдущая вершина, для начальной вершины равна -1.
    cout << "DFS at vertex " << v + 1 << endl;
    for (auto u: graph[v]) {
        if (u != p) {
            dfs(u, v);
        }
    }
}
```

## Заметки

Что касается выполнимых задач, стоит чётко уяснить один факт: **DFS не может находить кратчайшие пути**(для это необходимо использовать [[Алгоритм обхода графа в ширину(BFS)]]. Как бы вы не пытались его модифицировать, это ==невозможно по определению==. В остальном область применения DFS в основном совпадает с таковой у BFS, и выбор одного из алгоритмов - личное дело каждого.

На практике DFS чаще всего используют для проверка графа на _связность_, или более обобщённо, поиска _компонент связности_, _поиска циклов_ и работы с **деревьями**.

### Время исполнения

Мы имеем время выполнения, равное **O(V + E).**\
Краткое объяснение того, что означает V+E:\
V — общее количество вершин. E — общее количество граней (ребер).

Может показаться, что правильнее использовать V * E, однако давайте подумаем, что означает V * E.\
V * E означает, что применительно к каждой вершине, мы должны исследовать _все грани_ графа ==безотносительно принадлежности этих граней конкретной вершине==.

С другой стороны, V+E означает, что для каждой вершины мы оцениваем **лишь примыкающие** к ней грани. Возвращаясь к примеру, каждая вершина имеет определенное количество граней и, в худшем случае, мы обойдем все вершины (O(V)) и исследуем все грани (O(E)). Мы имеем V вершин и E граней, поэтому получаем V+E.

Далее, поскольку мы используем рекурсию для обхода каждой вершины, это означает, что используется стек (бесконечная рекурсия приводит к ошибке переполнения стека). Поэтому пространственная сложность составляет **O(V)**.

