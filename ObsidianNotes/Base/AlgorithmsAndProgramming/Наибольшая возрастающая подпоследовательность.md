#Algorithm #Cpp 
[[2022-06-14]]
# Наибольшая возрастающая подпоследовательность (с бинарным поиском)
#### Description 
Задача поиска **наибольшей увеличивающейся подпоследовательности** состоит в отыскании наиболее длинной возрастающей подпоследовательности в данной последовательности элементов.
### Алгоритмы
Существует основной алгоритм за время **O($n^{2}$)**. Его идея проста: в дополнительном массиве хранятся длины *наибольших возрастающий последовательнсотей*(НВП) до элемента с текущим индесом в исходном массиве. 
> [!seealso] Example
> 
Исходный массив {3 ,2, 5, 7}, тогда дополнительный будет {1, 1, 2, 3}

Есть возможность ==ускорить== и модифицировать алгоритм с помощью **Бинарного поиска**, тогда получится сократить издержки во времени до **O($n\log(n)$)**.
#### Любимый вариант
Реализация с *бинарным поиском* достаточно ==проста==.
1) Берем дополнительный список/вектор **dp** (беру динамические структуры данных просто ради удобства, при желани можно реализовать и массивами), иницилизируем первое значение первым элементом исходной последовательности.
2) Рассматриваем ==следующий элемент последовательности==:
	1) Если этот элемент больше последнего элемента dp, то добавляем это в **конец** списка *dp*.
	2) Иначе присваиваем элементу dp в **позиции**, ==найденной с помощью бинарного поиска==, элемент последовательности.
3) Возвращаться к действию 2, пока исходная последовательность не закончиться.
Таким образом, **мы получим список, длина которого и будет длиной наибольшей возрастающей подпоследовательности**.
```ad-danger
title: Большое НО
Алгоритм всегда верно определяет длину НВП за хорошее время, но в списке dp не во всех случаях будет храниться сама НВП, поэтому для восстановления НВП необходимо привлечь дополнительные меры

```

## Реализация в коде
```cpp
int BinSearch(vector<int>& arr, int target){
    int first = 0;
    int last = arr.size() - 1;
    while(first <= last){
        int medium = (first + last) / 2;
        if(arr[medium] == target) return medium;
        if(arr[medium] > target){
            last = medium - 1;
        }else{
            first = medium + 1;
        }
    }
    return first;
}

int BiggestSequience(vector<int>& test){
    vector<int> dp = {test[0]};
    int j = 0;
    for(int i = 1; i < test.size();i++)
    {
        if(test[i] <= dp[j]){
            dp[BinSearch(dp, test[i])] = test[i];

        }else{
            dp.push_back(test[i]);
            j++;
        }
    }
    return test.size();
}
```
## Замечания
- [ ] Реализовать восстановление наибольшей возрастающей подпоследовательнсти!

##### P.S. Есть решение задачи на C# с правильным восстановлением
Но я плохо понимаю идею реализации и код написан плохо. *==Нужно доработать!!!==*
Ссылка на яндекс-контест: [Вход — Динамическое программирование — Яндекс.Контест](https://contest.yandex.ru/contest/26701)
```Csharp
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace Practise
{
    class Program
    {
        static int BinSearch(int[] arr,int l , int r, int value)
        {
           
            for (int i = 0; i < 200; i++)
            {
                int mid = (l + r) / 2;
                //if (arr[mid] == value) return mid-1;
                if (value > arr[mid])
                {
                    l = mid+1;
                }
                else
                {
                    r = mid-1;
                }
            }
            return l;
        }
        static void NLogN(int n, int[]sequense)
        {
            int[] dp = new int[n].Select(x => x = int.MaxValue).ToArray();
            int[] minElementForLength = new int[n].Select(x => x = int.MaxValue).ToArray();
            int[] parent = new int[n].Select(x => x = -1).ToArray();
            dp[0] = 0;
            List<int> resSequense = new List<int>();
            minElementForLength[0] = sequense[0];
            int maxLength = 0;
            for (int i = 1; i < n; i++)
            {
                if (sequense[i] < minElementForLength[i] && sequense[i] > minElementForLength[i - 1])
                {
                    dp[i] = i;
                    if (maxLength < i) maxLength = i;
                    minElementForLength[i] = sequense[i];
                    parent[i] = dp[i - 1];
                }
                else
                {
                    int j = BinSearch(minElementForLength, 0, n, sequense[i]);
                    if (maxLength < j) maxLength = j;
                    dp[j] = i;
                    if(j-1>=0)  parent[i] = dp[j-1];
                    minElementForLength[j] =
                        (minElementForLength[j] > sequense[i]) ? sequense[i] : minElementForLength[j];                    
                }
            }
            int result = dp.Max() + 1;
            Console.WriteLine(maxLength+1);
            int p = dp[maxLength];
            while (p !=-1)
            {
                resSequense.Add(sequense[p]);
                p = parent[p];
            }

            for (int i = resSequense.Count - 1; i >= 0; i--)
            {
                Console.Write(resSequense[i]);
                if(i!=0) Console.Write(" ");
            }
        }
        static void Main()
        {
            int n = int.Parse(Console.ReadLine());
            if(n==1)
            {
            	int number = int.Parse(Console.ReadLine());
                Console.WriteLine(n);
                Console.WriteLine(number);    
            }else
            {
            int[] sequense = Console.ReadLine().Trim().Split().Select(x => int.Parse(x)).ToArray();
            NLogN(n,sequense);
            }            
        }        
    }
}
```