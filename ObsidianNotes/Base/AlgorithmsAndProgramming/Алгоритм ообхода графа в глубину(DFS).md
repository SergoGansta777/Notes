#Algorithm 
[[2022-06-21]]
# Алгоритм обхода/поиска в глубину(deapth-first search)
``Go deep, head first``
### Description
*Идея* заключается в том, что мы двигаемся от начальной вершины (точки, места) в определенном направлении (по определенному пути) до тех пор, ==пока не достигнем конца пути или пункта назначения== (искомой вершины). Если мы достигли конца пути, но он не является пунктом назначения, то мы **возвращаемся назад** (к точке разветвления или расхождения путей) и идем по *другому* маршруту.
## Реализация алгоритма
Специальный **DFS-алгоритм** позволяет проверить, возможно ли добраться из одного места в другое. DFS может использоваться в ==разных целях==. От этих целей зависит то, как будет выглядеть сам алгоритм. Тем не менее, общая концепция выглядит именно так.
#### Реализация для произвольного графа
```cpp
vector<int> graph[100000];
bool used[100000];      //вместо visited массив меток обычно называют used.

void dfs(int v) {
    used[v] = true;
    cout << "DFS at vertex " << v + 1 << endl;

    for (auto u: graph[v]) {
        if (!used[u]) {
            dfs(u);
        }
    }
}
```
#### Реализация для дерева
Очень часто DFS применяется не для произвольного графа, а для *дерева*. Это позволяет реализовать алгоритм немного по другому: за счёт ==отсутствия в дереве циклов== мы можем избавиться от **массива used**. Достаточно всего лишь передавать в функцию ещё <u>один параметр</u>: **предыдущую вершину**. Этот параметр необходим, чтобы *не попасть в бесконечный цикл из двух вершин* (постоянно проходя по одному и тому же ребру).
```cpp
vector<int> graph[100000];    //храним дерево как и обычный граф

void dfs(int v, int p = -1) {   //p (от parent) - предыдущая вершина, для начальной вершины равна -1.
    cout << "DFS at vertex " << v + 1 << endl;

    for (auto u: graph[v]) {
        if (u != p) {
            dfs(u, v);
        }
    }
}
```
## Заметки
Что касается выполнимых задач, стоит чётко уяснить один факт: **DFS не может находить кратчайшие пути**. Как бы вы не пытались его модифицировать, это ==невозможно по определению==. В остальном область применения DFS в основном совпадает с таковой у BFS, и выбор одного из алгоритмов - личное дело каждого.

На практике DFS чаще всего используют для проверка графа на *связность*, или более обобщённо, поиска *компонент связности*, *поиска циклов* и работы с **деревьями**.
### Время исполнения
Мы имеем время выполнения, равное **O(V + E).**  
Краткое объяснение того, что означает V+E:  
V — общее количество вершин. E — общее количество граней (ребер).  
  
  Может показаться, что правильнее использовать V * E, однако давайте подумаем, что означает V * E.  
  V * E означает, что применительно к каждой вершине, мы должны исследовать *все грани* графа ==безотносительно принадлежности этих граней конкретной вершине==.  
  
  С другой стороны, V+E означает, что для каждой вершины мы оцениваем **лишь примыкающие** к ней грани. Возвращаясь к примеру, каждая вершина имеет определенное количество граней и, в худшем случае, мы обойдем все вершины (O(V)) и исследуем все грани (O(E)). Мы имеем V вершин и E граней, поэтому получаем V+E.  
  
Далее, поскольку мы используем рекурсию для обхода каждой вершины, это означает, что используется стек (бесконечная рекурсия приводит к ошибке переполнения стека). Поэтому пространственная сложность составляет **O(V)**.