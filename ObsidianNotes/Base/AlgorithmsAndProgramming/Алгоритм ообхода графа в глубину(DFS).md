[[2022-06-21]]
#Algorithm 
# Алгоритм обхода/поиска в глубину(deapth-first search)
``Go deep, head first``
### Description
*Идея* заключается в том, что мы двигаемся от начальной вершины (точки, места) в определенном направлении (по определенному пути) до тех пор, ==пока не достигнем конца пути или пункта назначения== (искомой вершины). Если мы достигли конца пути, но он не является пунктом назначения, то мы **возвращаемся назад** (к точке разветвления или расхождения путей) и идем по *другому* маршруту.
## Реализация алгоритма
Специальный **DFS-алгоритм** позволяет проверить, возможно ли добраться из одного места в другое. DFS может использоваться в ==разных целях==. От этих целей зависит то, как будет выглядеть сам алгоритм. Тем не менее, общая концепция выглядит именно так.
#### Реализация для произвольного графа
```cpp
vector<int> graph[100000];
bool used[100000];      //вместо visited массив меток обычно называют used.

void dfs(int v) {
    used[v] = true;
    cout << "DFS at vertex " << v + 1 << endl;

    for (auto u: graph[v]) {
        if (!used[u]) {
            dfs(u);
        }
    }
}
```
#### Реализация для дерева
Очень часто DFS применяется не для произвольного графа, а для *дерева*. Это позволяет реализовать алгоритм немного по другому: за счёт ==отсутствия в дереве циклов== мы можем избавиться от **массива used**. Достаточно всего лишь передавать в функцию ещё <u>один параметр</u>: **предыдущую вершину**. Этот параметр необходим, чтобы *не попасть в бесконечный цикл из двух вершин* (постоянно проходя по одному и тому же ребру).